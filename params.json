{"name":"Jables","tagline":"Write Database Schema in JSON! (for Laravel5)","body":"# Jables (Beta)\r\nWrite your Database Schema in JSON. Let Jables handle the Rest. (For Laravel 5)\r\n\r\n> Did you ever contemplate how nice it would be if your migration files weren't named with such odd names and how easy it would be if bringing changes to a table meant you only had to change one file, and all of it stored nicely in your version control?\r\n> \r\n> Yeah we did too, so we created **Jables**.\r\n\r\n# Features\r\n- [x] Writing Schema in JSON\r\n- [x] Laravel Integration\r\n- [x] Comprehensive Field Types \r\n- [x] Error detection before Hitting the Database (can your migrations do that?)\r\n- [x] Checking JSON Syntax\r\n- [x] Checking Foreign key References.\r\n- [x] Checking Unique key Constraints.\r\n- [x] Table De-Construction Command\r\n- [ ] Table \"Diff\"-ing so we don't have to destroy and recreate all the tables all the time. (we're working on it)\r\n- [ ] Automatic Database Documentation generator (we're working on it)\r\n- [ ] JSON Prettifyer. we know you love nicely formatted code. (we're working on it)\r\n- [ ] Automatic Documentation Builder (we're working on it)\r\n\r\n# Installation\r\n\r\n## Grabing It\r\nFirst, we need to grab it through Composer (composer is required as we also depend on its autoloading facilities)\r\n\r\n```\r\ncomposer require hedronium/jables\r\n```\r\n\r\nor by adding it to the require list in you `composer.json` file, then calling `composer install`\r\n\r\n```JSON\r\nrequire: {\r\n    \"hedronium/jables\": \"dev-master\"\r\n}\r\n```\r\n\r\n## Registering It\r\nThis step is very important. You must add Jables to Laravel as a service provider.\r\n\r\nTo do this, open up your `config/app.php` and add \r\n`hedronium\\Jables\\JablesServiceProvider` to the Service Providers list. Like:\r\n\r\n```PHP\r\n'providers' => [\r\n    // .... other providers and stuff ...\r\n    hedronium\\Jables\\JablesServiceProvider::class\r\n]\r\n```\r\n\r\n## Check it out!\r\n\r\nOn the command line run\r\n```\r\nphp artisan\r\n```\r\nand check to see if the `jables` command and the `jables` section shows up.\r\n\r\n# Configuration\r\nJables usually works right out of the box with no configuration required, but if you do wanna get pokey, we have 2 configuration options for you.\r\n\r\nFirst publish the configuration files. with\r\n```\r\nphp artisan vendor:publish\r\n```\r\n\r\nafter running that a `jables.php` should show up in your `config` folder with the following contents...\r\n\r\n```PHP\r\n<?php\r\nreturn [\r\n    'table' => 'jables',\r\n    'folder' => 'jables'\r\n];\r\n```\r\n\r\n## Options\r\n- **table** - The name of the special table jables creates for tracking which tables have been created and which has not.\r\n- **folder** - The name of the folder within which you store your table schemas. The name is relative to your Laravel installation's `database` folder.\r\n\r\n> Yes it is highly suggested that you store it in a folder within your database folder but different from your migrations folder.\r\n\r\n# Usage\r\n## Writing Schemas\r\nThe schemas files are usually stored in the `database/jables` folder unless you configure it to be otherwise.\r\n\r\nThe Filename **is** your table name. So if you were to create a `users` table, your file name would be `users.json` nested under `database/jables`\r\n\r\n### Hello World! (in Jables)\r\n\r\n`food.json`\r\n\r\n```\r\n{\r\n    \"fields\": {\r\n        \"name\": {\r\n            \"type\": \"string\"\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nnow run `php artisan jables`. This will create a table named `food` with a field named `name` with the type being `varchar`.\r\n\r\n### The Formal Breakdown\r\nWell you define all your fields in the `fields` property on your root object of your json file. The `fields` property itself is an object and every property of the `fields` object corresponds to a table field.\r\n\r\nEach property (which are the field definitions) within the `fields` object is once again another object. The only hard requirement for it all is the `type` property on them. This tells jables what is the type of the field.\r\n\r\nin our 'hello world' example the type of `string` corresponds to `varchar` just like in Laravel migrations (ssssh, we actaully use Laravel's [Schema Builder](http://laravel.com/docs/5.1/migrations) behind the schenes, please don't tell anyone).\r\n\r\n## Types Available\r\nHeres a list\r\n\r\n- [big-integer](#big-integer)\r\n- [binary](#binary)\r\n- [boolean](#boolean)\r\n- [char](#char)\r\n- [date](#date)\r\n- [date-time](#date-time)\r\n- [decimal](#decimal)\r\n- [double](#double)\r\n- [enum](#enum)\r\n- [float](#fltoat)\r\n- [integer](#integer)\r\n- [json](#json)\r\n- [jsonb](#jsonb)\r\n- [long-text](#long-text)\r\n- [medium-integer](#medium-integer)\r\n- [medium-text](#medium-text)\r\n- [morphs](#morphs)\r\n- [small-integer](#small-integer)\r\n- [string](#string)\r\n- [text](#text)\r\n- [time](#time)\r\n- [tiny-integer](#tiny-integer)\r\n- [timestamp](#timestamp)\r\n\r\n### integer\r\n```JSON\r\n\"awesomeness\": {\r\n    \"type\": \"integer\"\r\n}\r\n```\r\n\r\nYou can write `attributes` which is a list. Currently only supports one attribute, the `unsigned` attribute\r\n\r\nlike...\r\n```JSON\r\n{\r\n    \"type\": \"integer\",\r\n    \"attributes\": [\r\n        \"unsigned\"\r\n    ]\r\n}\r\n```\r\n\r\nYou can only set it to auto-increment with the `ai` (`boolean`) property like...\r\n```JSON\r\n{\r\n    \"type\": \"integer\",\r\n    \"ai\" : true\r\n}\r\n```\r\n\r\n### big-integer\r\nSame as the average integer just write the type different like...\r\n```JSON\r\n{\r\n    \"type\": \"big-integer\"\r\n}\r\n```\r\n\r\n### medium-integer\r\nSame as the average integer just write the type different like...\r\n```JSON\r\n{\r\n    \"type\": \"medium-integer\"\r\n}\r\n```\r\n\r\n### small-integer\r\nSame as the average integer just write the type different like...\r\n```JSON\r\n{\r\n    \"type\": \"small-integer\"\r\n}\r\n```\r\n\r\n### tiny-integer\r\nSame as the average integer just write the type different like...\r\n```JSON\r\n{\r\n    \"type\": \"tiny-integer\"\r\n}\r\n```\r\n\r\n### float\r\nThe `FLOAT` type equivalent.\r\n```JSON\r\n{\r\n    \"type\": \"float\"\r\n}\r\n```\r\n\r\n### double\r\nThe `DOUBLE` type equivalent. It requires you to set the `digits` & `precision` properties.\r\n\r\n```JSON\r\n{\r\n    \"type\": \"double\",\r\n    \"digits\": 10,\r\n    \"precision\": 5\r\n}\r\n```\r\n\r\n### decimal\r\nThe `DECIMAL` type. Properties same as `double`.\r\n\r\n```JSON\r\n{\r\n    \"type\": \"decimal\",\r\n    \"digits\": 10,\r\n    \"precision\": 5\r\n}\r\n```\r\n\r\n### string\r\n`string` is the `VARCHAR` type, and it accepts a `length` property like...\r\n\r\n```JSON\r\n{\r\n    \"type\": \"string\",\r\n    \"length\": 50\r\n}\r\n```\r\n\r\nbut the `length` property isn't required.\r\n\r\n### char\r\nIts exactly like string it just uses the `CHAR` type and the `length` property is absolutely required. NO QUESTIONS!\r\n\r\n```JSON\r\n{\r\n    \"type\": \"char\",\r\n    \"length\": 10\r\n}\r\n```\r\n\r\n\r\n### text\r\nText doesn't require any special properties.\r\n\r\n```JSON\r\n{\r\n    \"type\": \"text\"\r\n}\r\n```\r\n\r\n### long-text\r\nSame as `text`.\r\n```JSON\r\n{\r\n    \"type\": \"long-text\"\r\n}\r\n```\r\n\r\n### medium-text\r\nSame as `text`.\r\n```JSON\r\n{\r\n    \"type\": \"medium-text\"\r\n}\r\n```\r\n\r\n### date\r\nNo Special Properties.\r\n```JSON\r\n{\r\n    \"type\": \"date\"\r\n}\r\n```\r\n\r\n### time\r\nNo Special Properties.\r\n```JSON\r\n{\r\n    \"type\": \"time\"\r\n}\r\n```\r\n\r\n### date-time\r\nNo Special Properties.\r\n```JSON\r\n{\r\n    \"type\": \"date-time\"\r\n}\r\n```\r\n\r\n### timestamp\r\nNo Special Properties.\r\n```JSON\r\n{\r\n    \"type\": \"timestamp\"\r\n}\r\n```\r\n\r\n### enum\r\nfor the `ENUM` type. It is required that you set the `values`(`list`) property.\r\n```JSON\r\n{\r\n    \"type\": \"enum\",\r\n    \"values\": [\"wizard\", \"muggle\"]\r\n}\r\n```\r\n\r\n### boolean\r\nNo special properties.\r\n```JSON\r\n{\r\n    \"type\": \"boolean\"\r\n}\r\n```\r\n\r\n### json\r\nNo special properties.\r\n```JSON\r\n{\r\n    \"type\": \"json\"\r\n}\r\n```\r\n\r\n### jsonb\r\nNo special properties.\r\n```JSON\r\n{\r\n    \"type\": \"jsonb\"\r\n}\r\n```\r\n\r\n### morphs\r\nNo special properties.\r\n```JSON\r\n{\r\n    \"type\": \"morphs\"\r\n}\r\n```\r\n\r\n### binary\r\nNo special properties.\r\n```JSON\r\n{\r\n    \"type\": \"binary\"\r\n}\r\n```\r\n\r\n## Timestamps\r\nYes, just like in Schema Builder, you can create the two fields `created_at` and `updated_at` in a simple way.\r\n\r\nJust create a special `timestamps` property in yours `fields` object and set it to true.\r\n\r\nLike:\r\n```JSON\r\n{\r\n    \"fields\": {\r\n        \"user_id\": {\r\n            \"type\": \"integer\",\r\n            \"attributes\": [\r\n                \"unsigned\"\r\n            ]\r\n        },\r\n        \"burger_id\": {\r\n            \"type\": \"integer\",\r\n            \"attributes\": [\r\n                \"unsigned\"\r\n            ]\r\n        },\r\n        \"timestamps\": true\r\n    }\r\n}\r\n```\r\n\r\n## Default Values\r\nAll field definitions accept the `default` property for when you want to set the default value of a field.\r\n\r\nUsed like...\r\n```JSON\r\n{\r\n    \"type\": \"string\",\r\n    \"default\": \"cake\"\r\n}\r\n```\r\n\r\n## Nullable Fields\r\nAll field definitions accept the `nullable`(`boolean`) property. If set to true, the field can be left null.\r\n\r\nUsed like...\r\n```JSON\r\n{\r\n    \"type\": \"string\",\r\n    \"nullable\": true\r\n}\r\n```\r\n\r\n## Primary Keys\r\nif you set the `ai` to true on a `integer` type or similar field. That field automatically becomes the primary key (its a Laravel thing).\r\n\r\nApart from that, you can set the `primary` property on any field to true like...\r\n```JSON\r\n{\r\n    \"type\": \"string\",\r\n    \"primary\": true\r\n}\r\n```\r\n\r\n### Composite Primary Keys\r\nMore that one field makes your primary key? No Problem! Just create a `primary`(`list`) property on your root object (sibling to your `fields` property) like...\r\n\r\n```JSON\r\n{\r\n    \"fields\": {\r\n        \"region\": {\r\n            \"type\": \"string\"\r\n        },\r\n        \"house\": {\r\n            \"type\": \"string\"\r\n        }\r\n    },\r\n    \"primary\": [\"region\", \"house\"]\r\n}\r\n```\r\n\r\nNow \"house stark of the north\" can be looked up without giving the starks a Numeric ID!\r\n\r\n## Unique Constraints\r\nAll field definitions accept the `unique` property. set it to `true` to make it an unique field like...\r\n\r\n```JSON\r\n{\r\n    \"type\": \"string\",\r\n    \"length\": 20,\r\n    \"unique\": true\r\n}\r\n```\r\n\r\n### Composite Unique Constraint\r\nYou can created unique constraints across many fields. Just create a `unique`(`list`) property on your root object (sibling to your `fields` property) like...\r\n\r\n```JSON\r\n{\r\n    \"fields\": {\r\n        \"region\": {\r\n            \"type\": \"string\"\r\n        },\r\n        \"house\": {\r\n            \"type\": \"string\"\r\n        }\r\n    },\r\n    \"unique\": [\r\n        [\"region\", \"house\"]\r\n    ]\r\n}\r\n```\r\n\r\nYes, it is a list inside a list. You know you could want to make multiple composite unique constraints, but at least now you know there can only be one house \"stark\" in the \"north\" region.\r\n\r\n## Foreign Key Constraints\r\nGot you covered! All fields accept the `foreign` property. You can set it to a string containing the name of the table and the name of the field of that table separated by a dot. (eg. `users.id`)\r\n\r\n```JSON\r\n\"user_id\": {\r\n    \"type\": \"integer\",\r\n    \"attributes\": [\r\n        \"unsigned\"\r\n    ],\r\n    \"foreign\": \"users.id\"\r\n}\r\n```\r\n\r\nthis `user_id` field will now reference `id` on the `users` table.\r\n\r\nYou could also define them like you define unique constraints like...\r\n```JSON\r\n{\r\n    \"fields\": {\r\n        \"user_id\": {\r\n            \"type\": \"integer\",\r\n            \"attributes\": [\r\n                \"unsigned\"\r\n            ]\r\n        },\r\n        \"burger_id\": {\r\n            \"type\": \"integer\",\r\n            \"attributes\": [\r\n                \"unsigned\"\r\n            ]\r\n        }\r\n    },\r\n    \"foreign\": {\r\n        \"user_id\": \"users.id\",\r\n        \"burger_id\": \"burgers.id\"\r\n    }\r\n}\r\n```\r\nThis will work totally fine.\r\n\r\n# Commands\r\n## jables\r\n```\r\nphp artisan jables\r\n```\r\nChecks your JSON files then creates your Database Tables\r\n\r\n## jables:check\r\n```\r\nphp artisan jables:check\r\n```\r\nChecks your JSOn files and reports errors.\r\n\r\n## jables:refresh\r\n```\r\nphp artisan jables:refresh\r\n```\r\nDestroys all the tables then recreates them from your (possibly updated) json files.\r\n(warning. risk of data loss)\r\n\r\n## jables:destroy\r\n```\r\nphp artisan jables:destroy\r\n```\r\nRemoves all the tables that jables created from Database.\r\n\r\n## jables:create-table\r\n```\r\nphp artisan jables:create-table\r\n```\r\nCreates Jables' own tracking table in database.\r\n\r\n# Options\r\nAll commands just accept one option. That is the `--database=[connection]` option. You can use it to override which connection Jables uses to do its business.\r\n\r\nexample\r\n```\r\nphp artisan jables --database=memory\r\n```\r\n\r\n# Documenting Tables\r\nAll field and table definitions accept `title` and `description` properties that can be used to document your database schema.\r\n\r\nWe're also working on a feature that generates HTML documentation from your JSON files but for now, you gotta create it on your own. (Maybe even send us a pull request. PLEASE. WE'RE DESPERATE.)\r\n\r\nexample:\r\n```JSON\r\n{\r\n    \"title\": \"Food\",\r\n    \"description\": \"FOOOD! GLORIOUS FOOD!\",\r\n    \"fields\": {\r\n        \"name\": {\r\n            \"type\": \"string\",\r\n            \"title\": \"Name\",\r\n            \"description\": \"Name of the food.\"\r\n        }\r\n    }\r\n}\r\n```","google":"UA-65319241-1","note":"Don't delete this file! It's used internally to help with page regeneration."}